import { PDFDocument } from "@peculiarventures/pdf-doc";

/**
 * An interface representing a repair rule for a PDF document.
 */
export interface IRepairRule {
  /**
   * The ID of the repair rule.
   */
  id: string;
  /**
   * A description of the repair rule.
   */
  description: string;
  /**
   * Applies the repair rule to a PDF document.
   * @param doc The PDF document to repair.
   * @returns A string representing the repair note generated by the rule, or null if no repair was performed.
   */
  apply: (doc: PDFDocument) => Promise<string[]>;
}

/**
 * A registry for PDF repair rules.
 */
export class PDFRepairRegistry {
  private rules: Map<string, IRepairRule> = new Map();

  /**
   * Checks if a rule with the given ID exists in the registry.
   * @param id The ID of the rule to check for.
   * @returns True if a rule with the given ID exists in the registry, false otherwise.
   */
  public hasRule(id: string): boolean {
    return this.rules.has(id);
  }

  /**
   * Adds a repair rule to the registry.
   * @param rule - The repair rule to add.
   * @throws An error if a repair rule with the same ID already exists in the registry.
   */
  public addRule(rule: IRepairRule): void {
    if (this.hasRule(rule.id)) {
      throw new Error(`A repair rule with id '${rule.id}' already exists.`);
    }
    this.rules.set(rule.id, rule);
  }

  /**
   * Retrieves a repair rule from the registry by its ID.
   * @param id The ID of the repair rule to retrieve.
   * @returns The repair rule with the specified ID, or undefined if no such rule exists.
   */
  public getRule(id: string): IRepairRule | undefined {
    return this.rules.get(id);
  }

  /**
   * Returns an array of repair rules. If `ids` is provided, only the rules with the specified IDs are returned.
   * @param ids An optional array of rule IDs to filter the results by.
   * @returns An array of repair rules.
   */
  public getRules(ids?: string[]): IRepairRule[] {
    if (ids) {
      return ids
        .map((id) => this.rules.get(id))
        .filter((rule) => rule) as IRepairRule[];
    }

    return Array.from(this.rules.values());
  }

  /**
   * Returns an iterator of all the keys in the registry.
   * @returns An iterator of all the keys in the registry.
   */
  public keys(): IterableIterator<string> {
    return this.rules.keys();
  }

  /**
   * Returns a new PDFRepairRegistry instance containing only the rules that satisfy
   * the provided testing function.
   * @param cb A function that accepts a repair rule and returns a boolean
   * indicating whether the rule should be included in the filtered registry.
   * @returns A new PDFRepairRegistry instance containing only the rules that
   * satisfy the provided testing function.
   */
  public filter(cb: (rule: IRepairRule) => boolean): PDFRepairRegistry {
    const registry = new PDFRepairRegistry();
    for (const rule of this.rules.values()) {
      if (cb(rule)) {
        registry.addRule(rule);
      }
    }

    return registry;
  }
}

export const globalRepairRegistry = new PDFRepairRegistry();
